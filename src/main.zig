const std = @import("std");
const builtin = @import("builtin");
const Fuzzer = @import("Fuzzer.zig");
const ChildProcess = std.ChildProcess;
const Mode = Fuzzer.Mode;
const Args = Fuzzer.Args;

const Markov = @import("modes/Markov.zig");

pub const std_options = struct {
    pub const log_level = std.log.Level.info;

    pub fn logFn(
        comptime level: std.log.Level,
        comptime scope: @TypeOf(.EnumLiteral),
        comptime format: []const u8,
        args: anytype,
    ) void {
        if (@intFromEnum(level) > @intFromEnum(log_level)) return;

        const level_txt = comptime level.asText();

        std.debug.print("{d} | {s}: ({s}): ", .{ std.time.milliTimestamp(), level_txt, @tagName(scope) });
        std.debug.print(format ++ "\n", args);
    }
};

fn parseArgs(allocator: std.mem.Allocator, envmap: std.process.EnvMap) !Args {
    var argsit = try std.process.ArgIterator.initWithAllocator(allocator);
    _ = argsit.next();

    const zls_path = argsit.next() orelse
        envmap.get("zls_path") orelse
        return usage("error: zls path is missing.", .{});
    if (std.mem.eql(u8, zls_path, "--help")) return usage("", .{});

    const modearg = argsit.next() orelse
        envmap.get("mode") orelse
        return usage("error: mode is missing.", .{});

    const mode: Mode = std.meta.stringToEnum(Mode, modearg) orelse
        return usage("error: invalid mode '{s}'.", .{modearg});
    var sub_mode: enum { positional, named } = .positional;

    var args: Args = .{
        .argsit = argsit,
        .zls_path = zls_path,
        .base = switch (mode) {
            .markov => .{ .markov = .{ .training_dir = "" } },
        },
    };

    while (argsit.next()) |arg| {
        switch (mode) {
            .markov => {
                if (sub_mode == .positional) {
                    args.base.markov.training_dir = arg;
                    sub_mode = .named;
                } else {
                    const marg = std.meta.stringToEnum(Args.MarkovArg, arg) orelse
                        return usage("error: invalid markov arg '{s}'", .{arg});

                    switch (marg) {
                        .@"--maxlen" => args.base.markov.maxlen = parseArg(u32, &argsit) catch
                            return usage("error: invalid value for markov --maxlen.", .{}),
                        .@"--cycles-per-gen" => args.base.markov.cycles_per_gen = parseArg(u32, &argsit) catch
                            return usage("error: invalid value for markov --cycles-per-gen.", .{}),
                    }
                }
            },
        }
    }

    // make sure required args weren't skipped
    switch (mode) {
        .markov => {
            if (args.base.markov.training_dir.len == 0)
                args.base.markov.training_dir = envmap.get("markov_training_dir") orelse
                    return usage("error: missing required positional argument 'markov training-dir'", .{});
        },
    }

    return args;
}

fn parseArg(comptime T: type, args: *std.process.ArgIterator) !T {
    const tinfo = @typeInfo(T);
    const arg = args.next() orelse return error.NoArg;

    return switch (tinfo) {
        .Int => try std.fmt.parseInt(T, arg, 10),
        else => @compileError("unsupported type '" ++ @typeName(T) ++ "'"),
    };
}

pub fn loadEnv(allocator: std.mem.Allocator) !std.process.EnvMap {
    var envmap = try std.process.getEnvMap(allocator);
    const envfile = std.fs.cwd().openFile(".env", .{}) catch |e| switch (e) {
        error.FileNotFound => return envmap,
        else => return e,
    };
    const reader = envfile.reader();
    var buf: [256]u8 = undefined;
    while (try reader.readUntilDelimiterOrEof(&buf, '\n')) |line| {
        if (std.mem.indexOfScalar(u8, line, '=')) |eqlidx| {
            const key = line[0..eqlidx];
            const val = line[eqlidx + 1 ..];
            try envmap.put(try allocator.dupe(u8, key), try allocator.dupe(u8, val));
        } else {
            try envmap.put(line, "");
        }
    }
    return envmap;
}

const UsageError = error{usage};
fn usage(comptime message: []const u8, message_args: anytype) UsageError {
    // note: if you change this text don't forget to run `zig build run -- --help`
    // and paste the contents into the README
    const fmt =
        \\
        \\ usage: zig build run <?block len> -- <zls path> <mode> <mode specific arguments>
        \\
        \\ * zls path  - required first arg - path to the zls executable
        \\ * mode      - required second arg - one of [{s}]
        \\
        \\   * mode == markov
        \\     training-dir     - required first arg - directory to be used for training
        \\                        the markov model. searched for .zig files recursively.
        \\     --maxlen         - optional: default={} - maximum length of each file
        \\                        generated by the markov model.
        \\     --cycles-per-gen - optional: default={} - how many times to fuzz a random
        \\                        feature before regenerating a new file.
        \\
        \\ * block len - optional build parameter: default=8 - applies only when
        \\               mode == markov.  the number of characters considered when
        \\               choosing a random transition.
        \\
        \\
    ;
    std.debug.print("\n" ++ message ++ "\n" ++ fmt, message_args ++ .{ std.meta.fieldNames(Mode), Args.Markov.Defaults.maxlen, Args.Markov.Defaults.cycles_per_gen });
    return error.usage;
}

pub fn main() !void {
    var main_arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    const allocator = main_arena.allocator();

    var args = parseArgs(allocator, try loadEnv(allocator)) catch {
        std.os.exit(1);
    };
    defer args.deinit();
    const zig_version = comptime std.fmt.comptimePrint("{any}", .{builtin.zig_version});

    const vers = try ChildProcess.exec(.{
        .allocator = allocator,
        .argv = &.{ args.zls_path, "--version" },
    });
    defer allocator.free(vers.stdout);
    defer allocator.free(vers.stderr);

    const zls_version = vers.stdout;

    std.log.info("Running with Zig version {s} and zls version {s}", .{ zig_version, zls_version });

    std.debug.print("parsed args: {}\n", .{args});

    var fuzzer = try Fuzzer.create(
        allocator,
        args,
        zig_version,
        zls_version,
    );
    defer fuzzer.deinit();
    try fuzzer.initCycle();
    var markov = try Markov.init(allocator, fuzzer);
    defer markov.deinit();

    try std.fs.cwd().makePath("saved_logs");
    const principal_path = try std.fs.path.join(main_arena.allocator(), &.{ "staging", "markov", "principal.zig" });

    while (true) {
        var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
        defer arena.deinit();

        if (fuzzer.connection.id >= 100_000) {
            std.log.info("Fuzzer running too long with no result... restarting", .{});

            _ = try fuzzer.connection.requestSync(arena.allocator(), "shutdown", {});
            try fuzzer.connection.notify("exit", {});

            markov.cycle = 0;
            fuzzer.kill();

            try fuzzer.reset();
            try fuzzer.initCycle();
            try markov.openPrincipal();
        }

        markov.fuzz(arena.allocator()) catch {
            std.log.info("Restarting fuzzer...", .{});
            markov.cycle = 0;
            fuzzer.kill();

            var buf: [512]u8 = undefined;
            const log_dir = try std.fmt.bufPrint(&buf, "saved_logs/{d}", .{std.time.milliTimestamp()});
            try std.fs.cwd().rename("logs", log_dir);
            try std.fs.cwd().copyFile(principal_path, try std.fs.cwd().openDir(log_dir, .{}), "principal.zig", .{});

            try fuzzer.reset();
            try fuzzer.initCycle();
            try markov.openPrincipal();
        };
    }
}
