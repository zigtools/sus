const std = @import("std");
const markov = @import("markov.zig");
const build_options = @import("build_options");

const Markov = @This();

const MarkovModel = markov.Model(build_options.block_len, false);

model: MarkovModel,
random: std.rand.DefaultPrng,
maxlen: u32 = Defaults.maxlen,

const Defaults = struct {
    pub const maxlen = 512;
};

const usage =
    std.fmt.comptimePrint(
    \\Usage Markov Mode:
    \\     --training_dir   - directory to be used for training. searched for .zig files recursively.
    \\     --maxlen         - maximum length of each file generated by the markov model. (default: {d})
, .{
    Defaults.maxlen,
});

fn fatal(comptime format: []const u8, args: anytype) noreturn {
    std.log.err(format, args);
    std.process.exit(1);
}

pub fn init(
    allocator: std.mem.Allocator,
    progress: *std.Progress,
    arg_it: *std.process.ArgIterator,
    envmap: std.process.EnvMap,
) !*Markov {
    var seed: u64 = 0;
    try std.os.getrandom(std.mem.asBytes(&seed));

    var mm = try allocator.create(Markov);
    mm.* = .{
        .model = undefined, // set below
        .random = std.rand.DefaultPrng.init(seed),
    };
    errdefer mm.deinit(allocator);

    mm.model = MarkovModel.init(allocator, mm.random.random());

    var training_dir: ?[]const u8 = envmap.get("markov_training_dir");

    while (arg_it.next()) |arg| {
        if (std.mem.eql(u8, arg, "--help")) {
            // TODO
        } else if (std.mem.eql(u8, arg, "--training-dir")) {
            training_dir = arg_it.next() orelse fatal("expected directory path after --training-dir", .{});
        } else if (std.mem.eql(u8, arg, "--maxlen")) {
            const next_arg = arg_it.next() orelse fatal("expected integer after --maxlen", .{});
            mm.maxlen = std.fmt.parseUnsigned(u32, next_arg, 10) catch fatal("expected integer after --maxlen", .{});
        } else {
            fatal("invalid markov arg '{s}'", .{arg});
        }
    }

    // make sure required args weren't skipped
    if (training_dir == null or training_dir.?.len == 0) {
        fatal("missing mode argument '--training-dir'", .{});
    }

    progress.log(
        \\
        \\training_dir:   {s}
        \\maxlen:         {d}
        \\
        \\
    , .{ training_dir.?, mm.maxlen });

    var progress_node = progress.start("markov: feeding model", 0);
    defer progress_node.end();

    var iterable_dir = try std.fs.cwd().openIterableDir(training_dir.?, .{});
    defer iterable_dir.close();

    {
        var walker = try iterable_dir.walk(allocator);
        defer walker.deinit();
        var file_count: usize = 0;
        while (try walker.next()) |entry| {
            if (entry.kind != .file) continue;
            if (!std.mem.eql(u8, std.fs.path.extension(entry.basename), ".zig")) continue;
            file_count += 1;
        }
        progress_node.setEstimatedTotalItems(file_count);
    }

    var walker = try iterable_dir.walk(allocator);
    defer walker.deinit();

    var file_buf = std.ArrayListUnmanaged(u8){};
    defer file_buf.deinit(allocator);

    progress_node.activate();
    while (try walker.next()) |entry| {
        if (entry.kind != .file) continue;
        if (!std.mem.eql(u8, std.fs.path.extension(entry.basename), ".zig")) continue;

        // std.log.info("found file: {s}", .{entry.path});
        progress_node.completeOne();

        var file = try entry.dir.openFile(entry.basename, .{});
        defer file.close();

        const size = std.math.cast(usize, try file.getEndPos()) orelse return error.FileTooBig;
        try file_buf.ensureTotalCapacity(allocator, size);
        file_buf.items.len = size;
        _ = try file.readAll(file_buf.items);

        try mm.model.feed(file_buf.items);
    }

    mm.model.prep();

    return mm;
}

pub fn deinit(mm: *Markov, allocator: std.mem.Allocator) void {
    mm.model.deinit(allocator);
    mm.* = undefined;
    allocator.destroy(mm);
}

pub fn gen(mm: *Markov, allocator: std.mem.Allocator) ![]const u8 {
    var buffer = try std.ArrayListUnmanaged(u8).initCapacity(allocator, mm.maxlen);
    errdefer buffer.deinit(allocator);
    try mm.model.gen(buffer.writer(allocator), .{ .maxlen = mm.maxlen });
    return try buffer.toOwnedSlice(allocator);
}
