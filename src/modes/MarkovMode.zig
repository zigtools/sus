const std = @import("std");
const markov = @import("markov.zig");
const build_options = @import("build_options");

const Markov = @This();

const MarkovModel = markov.Model(build_options.block_len, false);

model: MarkovModel,
random: std.Random.DefaultPrng,
maxlen: u32 = Defaults.maxlen,

const Defaults = struct {
    pub const maxlen = 512;
};

const usage = std.fmt.comptimePrint(
    \\Usage Markov Mode:
    \\     --training-dir   - directory to be used for training. searched for .zig files recursively.
    \\     --maxlen         - maximum length of each file generated by the markov model. (default: {d})
    \\
, .{
    Defaults.maxlen,
});

fn fatalWithUsage(comptime format: []const u8, args: anytype) noreturn {
    std.io.getStdErr().writeAll(usage) catch {};
    std.log.err(format, args);
    std.process.exit(1);
}

fn fatal(comptime format: []const u8, args: anytype) noreturn {
    std.log.err(format, args);
    std.process.exit(1);
}

pub fn init(
    allocator: std.mem.Allocator,
    progress: std.Progress.Node,
    arg_it: *std.process.ArgIterator,
    envmap: std.process.EnvMap,
) !*Markov {
    const seed = std.crypto.random.int(u64);

    var mm = try allocator.create(Markov);
    mm.* = .{
        .model = .{ .allocator = allocator },
        .random = std.Random.DefaultPrng.init(seed),
    };
    errdefer mm.deinit(allocator);

    var training_dir: ?[]const u8 = envmap.get("markov_training_dir");

    if (envmap.get("markov_maxlen")) |str| {
        mm.maxlen = std.fmt.parseUnsigned(u32, str, 10) catch |err| blk: {
            std.log.warn("expected unsigned integer in env option 'markov_maxlen' but got '{s}': {}", .{ str, err });
            break :blk Defaults.maxlen;
        };
    }

    while (arg_it.next()) |arg| {
        if (std.mem.eql(u8, arg, "--help")) {
            try std.io.getStdOut().writeAll(usage);
            std.process.exit(0);
        } else if (std.mem.eql(u8, arg, "--training-dir")) {
            training_dir = arg_it.next() orelse fatalWithUsage("expected directory path after --training-dir", .{});
        } else if (std.mem.eql(u8, arg, "--maxlen")) {
            const next_arg = arg_it.next() orelse fatal("expected integer after --maxlen", .{});
            mm.maxlen = std.fmt.parseUnsigned(u32, next_arg, 10) catch fatalWithUsage("expected integer after --maxlen", .{});
        } else {
            fatalWithUsage("invalid markov arg '{s}'", .{arg});
        }
    }

    // make sure required args weren't skipped
    if (training_dir == null or training_dir.?.len == 0) {
        fatalWithUsage("missing mode argument '--training-dir'", .{});
    }

    std.debug.print(
        \\
        \\training-dir:   {s}
        \\maxlen:         {d}
        \\
        \\
    , .{ training_dir.?, mm.maxlen });

    var progress_node = progress.start("markov: feeding model", 0);
    defer progress_node.end();

    var iterable_dir = try std.fs.cwd().openDir(training_dir.?, .{ .iterate = true });
    defer iterable_dir.close();

    {
        var walker = try iterable_dir.walk(allocator);
        defer walker.deinit();
        var file_count: usize = 0;
        while (try walker.next()) |entry| {
            if (entry.kind != .file) continue;
            if (!std.mem.eql(u8, std.fs.path.extension(entry.basename), ".zig")) continue;
            file_count += 1;
            progress_node.setEstimatedTotalItems(file_count);
        }
    }

    var walker = try iterable_dir.walk(allocator);
    defer walker.deinit();

    var file_buf = std.ArrayListUnmanaged(u8){};
    defer file_buf.deinit(allocator);

    while (try walker.next()) |entry| {
        if (entry.kind != .file) continue;
        if (!std.mem.eql(u8, std.fs.path.extension(entry.basename), ".zig")) continue;

        // std.log.info("found file: {s}", .{entry.path});

        var file = try entry.dir.openFile(entry.basename, .{});
        defer file.close();

        const size = std.math.cast(usize, try file.getEndPos()) orelse return error.FileTooBig;
        try file_buf.ensureTotalCapacity(allocator, size);
        file_buf.items.len = size;
        _ = try file.readAll(file_buf.items);

        try mm.model.feed(file_buf.items);

        progress_node.completeOne();
    }

    mm.model.prep();

    return mm;
}

pub fn deinit(mm: *Markov, allocator: std.mem.Allocator) void {
    mm.model.deinit(allocator);
    mm.* = undefined;
    allocator.destroy(mm);
}

pub fn gen(mm: *Markov, allocator: std.mem.Allocator) ![]const u8 {
    var buffer = try std.ArrayListUnmanaged(u8).initCapacity(allocator, mm.maxlen);
    errdefer buffer.deinit(allocator);
    try mm.model.gen(mm.random.random(), buffer.writer(allocator), .{ .maxlen = mm.maxlen });
    return try buffer.toOwnedSlice(allocator);
}
